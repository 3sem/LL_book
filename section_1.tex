\sloppy

\chapter {Алгоритмы нисходящего синтаксического анализа}



\section{Нисходящий синтаксический анализ}
Нисходящий синтаксический анализ идеологически можно рассматривать как задачу поиска левого порождения входной строки, либо, что эквивалентно, как процесс построения дерева разбора добавлением узлов в прямом порядке обхода в глубину, начиная с корня. 

Для контекстно-свободной (КС) грамматики $G = \langle \Sigma, N, S, P \rangle$ огранизация нисходящего анализа выглядит следующим образом: анализатор, разбирающий входную строку $w$, заканчивающуюся символом конца строки $\$$, в каждый момент работы содержит в своей памяти пару $(\alpha, v)$, где $v$ -- ещё не прочитанная часть входной строки. Алгоритм анализа пытается разобрать $v$ как конкатенацию $\alpha=X_1\dots{X_l}$,где $l \geq{0}, X_1,\dots{,X_l} \in \Sigma\cup{N}$ --- последовательность символов, хранящаяся на стеке так, что $X_1$ лежит на вершине. На каждом шаге ключевым действием является определение правила, применяемого для раскрытия соответствующего нетерминала. Когда правило выбрано, следует произвести проверку соответствия  входной строки и терминальных символов правой части правила, и выполнить дальнейшие шаги для её нетерминальных символов. Если в конце разбора $v=\$$, то есть удалось дойти до конца строки, и при этом все нетерминалы удалось раскрыть, --- строка успешно разобрана.

В данной главе мы рассмотрим два подхода к нисходящему анализу: LL-анализ, использующий входной буфер, стек для хранения промежуточных данных, и управляющую таблицу, хранящую правила, применяемые в ходе анализа, а также анализ методом рекурсивного спуска, использующий в качестве стека стек вызовов программных процедур, реализующих применение правил в соответствующих ситуациях.

Дадим необходимые определения.
\\
{\bf$\blacktriangle$ Определение 1.} 
Говорят, что грамматика содержит \textit{левую рекурсию}, если в ней существует вывод вида $A \vdash^* A\alpha$. Если при этом в грамматике содержится правило $A \vdash A\alpha$, левая рекурсия называется непосредственной, или явной. В противном случае левая рекурсия называется косвенной, или неявной. 
\\
{\bf$\blacktriangle$ Определение 2.} 
Грамматика называется \textit{однозначной}, если у каждого слова имеется не более одного дерева разбора в этой грамматике.
\\
{\bf$\blacktriangle$ Определение 3.} 
\textit{Левым порождением}, или левосторонним выводом слова $\omega$
называется такой вывод $\omega$, в котором каждая последующая строка получена из предыдущей заменой самого левого встречающегося в строке нетерминала по одному из правил. Символически, левое порождение обозначается как $\vdash^{*}_{lm}$, а любой его шаг --- как $\vdash_{lm}$.
\begin{flushleft}
	
	\begin{tabular}  {p{2.20cm}  p{8.30cm}}
		{\bf\normalsize Лемма 1}
		& \emph{Пусть	$G = \langle \Sigma, N, S, P \rangle$ — КС-грамматика. Предположим, что существует дерево разбора с корнем, отмеченным $A$, и кроной  $\omega \in \Sigma^{*}$. Тогда в грамматике $G$ существует левое порождение $A \vdash^{*}_{lm} \omega$.}
	\end{tabular}
	
\end{flushleft}	

\textbf{Доказательство} производится индукцией по высоте дерева (рекомендуем читателям проделать его самим).
\begin{flushleft}
	
	\begin{tabular}  {p{2.20cm}  p{8.30cm}}
		{\bf\normalsize Лемма 2}
		& \emph{Для каждой грамматики $G = \langle \Sigma, N, S, P \rangle$ и $\omega \in \Sigma^{*}$, цепочка $\omega$ имеет два разных дерева разбора тогда и только тогда, когда $\omega$ имеет два разных левых порождения из $P$.}
	\end{tabular}
	
\end{flushleft}	

Для описания построения нисходящего анализатора введем два вспомогательных множества, содержащих, соответсвенно, все возможные первые и непосредственно следующие $k$ символов в результирующем выводе.

{\bf$\blacktriangle$ Определение 4.}
	Пусть $G = \langle N, \Sigma, P, S \rangle$~--- КС-грамматика. Множество $FIRST_{k}$ определяется для сентенциальной формы $\alpha$ как:\\
	$FIRST_{k}(\alpha) = \{ \omega \in \Sigma^* \mid \alpha \to^{*} \omega \text{ и } |\omega| < k$ либо $ \exists \beta: \alpha \to^{*} \omega \beta \text{ и } |\omega| = k \}
	$
	, где $\alpha, \beta \in (N \cup \Sigma)^*.$ 


{\bf$\blacktriangle$ Определение 5.}
Пусть $G = \langle N, \Sigma, P, S \rangle$~--- КС-грамматика. Множество $FOLLOW_{k}$ строки формы $\beta \in (\Sigma \cup \Gamma)^*$ как:\\
$FOLLOW_{k}(\beta) = \{ \omega \in \Sigma^* \mid \exists \gamma, \alpha: S \vdash^{*} \gamma \beta \alpha$ и $ \omega \in FIRST_{k}(\alpha) \}$

Cогласно определениям, $FIRST_{k}(A)$ и $FOLLOW_{k}(A)$ содержат, соответсвенно, все возможные первые и непосредственно следующие $k$ символов в результирующем выводе, при использовании нетерминала $A$

Пусть дана грамматика  $\langle \Sigma, N, S, P \rangle$. Алгоритм построения $FIRST_k$ следующий: 

\begin{algorithm}[H]\label{alg:FIRSTK}
	\begin{algorithmic}
		\State{$\forall A \in N, FIRST_k(A) \gets \varnothing$}
		\State{$\forall a \in \Sigma, FIRST_k(a) \gets \{a\}$}
		\While{$FIRST_k(A)|_{a \in N}$ изменяется}
		\For{$A \vdash X_1\dots{X_l} \in P$}
		\State {$FIRST_k(A)\gets{FIRST_k(FIRST_k(X_1)\cdot \dots {\cdot{FIRST_k(X_l)}})}$}
		\EndFor
		\EndWhile
		
	\end{algorithmic}
\end{algorithm}

Для построения $FOLLOW_k$ нужно выполнить сдедующее:

\begin{algorithm}[H]\label{alg:FOLLOWK}
	\begin{algorithmic}
		\State{$ FOLLOW_k(S) \gets \{\varepsilon\}$}
		\State{$\forall A \in N\setminus{\{S\}}\  FOLLOW_k(A)\gets{\varnothing}$}
		
		\While{$FOLLOW_k(A)|_{A \in N}$ изменяется}
		\For{$B \vdash \beta \in P$}
		\For{$\beta=\mu A \nu$ разбиений, где $A \in N, \mu,\nu \in (\Sigma \cup{\{\$\}} \cup N)^*$}
		\State {$FOLLOW_k(A)\gets FOLLOW_k(A)\cup FIRST_k( FIRST_k(\nu)\cdot$ 
		\State $\cdot{FOLLOW_k(B)})$}
		\EndFor
		\EndFor
		\EndWhile
	\end{algorithmic}
\end{algorithm}


Введём понятие таблицы, управляющей разбором.
{\bf$\blacktriangle$ Определение 6.}
Управляющая таблица для грамматики $G=\langle\Sigma,N,P,S\rangle$ -- это частичная фунция $T_k:N\times{\Sigma^{\leq{k}}}\vdash{P\cup{\{-\}}}$, отображающая пару: нетерминал $A$ и $m$ терминальных символов~--- $t_{1} \dots t_{m}$, где $m \leq k$ --- в правило, которое нужно применять, если такое правило есть в $P$. 

По строкам в управляющей таблице размещаются все нетерминалы грамматики, по столбцам -- всевозможные последовательности терминалов, длиной не более $k$\footnote{На практике таблица может получиться довольно разреженной, поэтому столбцы для последовательностей, не выводимых из нетерминалов грамматики, опускают}$^,$\footnote{Теоретически показательный характер роста количества столбцов от $k$ на практике, как правило, не реализуется, так как реальные языки программирования обычно не задаются грамматиками, дающими теоретически худший случай}, а также столбец для маркера конца строки --- $\$$. 
В ячейке таблицы указано правило, которое нужно применять, если рассматривается нетерминал $A$, а следующие $m$ символов строки~--- $t_{1} \dots t_{m}$, где $m \leq k$, либо прочерк, если такого правила нет.

\begin{center}
	\begin{tabular}{ c | c | c | c | c }
		& $\dots$ & $t_{1} \dots t_{m}$ & $\dots$ & $\$$ \\ \hline  
		$\dots$  & $\dots$ & $\dots$ & $\dots$ & $\dots$ \\ \hline  
		$A$  & $\dots$ & $A \vdash \alpha$ & $\dots$ & $\dots$ \\ \hline  
		$\dots$  & $\dots$ & $\dots$ & $\dots$ & $\dots$ 
	\end{tabular}  
\end{center}

Управляющая таблица строится алгоритмически на основании построения для каждого нетерминала $A$ вспомогательных множеств $FIRST_{k}(A)$ и $FOLLOW_{k}(A)$.

Приведём алгоритм построения $T_k$ для всех $A \in N$ и $x \in \Sigma^{\leq{k}}\cup{\{\$\}}, k > 0$ по $FIRST_k$ и $FOLLOW_k$ (в начале элементы $T_k$ инициализированы '---'). 

\begin{algorithm}[tbh]\label{alg:TK}
	\begin{algorithmic}
		
		\For{$A \vdash \alpha \in P$}
		\For{$x \in FIRST_{k}(FIRST(\alpha)\cdot{FOLLOW_k(A)})$}
		\If{$T_k(A,x)=$'---'}
		\State{$T_k(A,x)\gets(A\vdash{\alpha})$}
		\Else
		\State{Произошел конфликт: нет однозначного правила для $A,x$}
		\EndIf
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}


Заметим, что в псевдокоде построения таблицы ветвь с сообщением о конфликте нужна для сигнализирования о неоднозначности в заполнении ячейки: не для всех КС-грамматик по множествам $FIRST_{k}$ и $FOLLOW_{k}$ возможно выбрать применяемое правило, следовательно, нельзя и построить однозначную управляющую таблицу. Класс грамматик, для которых управляющую таблицу можно построить без конфликтов, называют классом LL(k)-грамматик.

{\bf$\blacktriangle$ Определение 7.}
LL(k) грамматика --- грамматика, для которой для некоторого $k\geq{1}$ существует управляющая таблица $T_k$, по которой можно однозначно определить, какое правило применять.
\begin{flushleft}
	
	\begin{tabular}  {p{2.20cm}  p{8.30cm}}
		{\bf\normalsize Теорема 3. (о построении управляющей таблицы)}
		& \emph{Для LL(k)-грамматики $G = \langle N, \Sigma, P, S \rangle$, для любого её правила вида $A \vdash X_1\dots{X_l} \in P$, если $x \in FIRST_k(FIRST_k(X_1)\cdot{}\dots{\cdot{}{FIRST_k(X_l)}}\cdot$ $\cdot{FOLLOW_k(A)})$, то ячейка управляющей таблицы $T_k(A, x)$ содержит единственное правило $A \vdash X_1\dots{X_l}$.}.
	\end{tabular}
	
\end{flushleft}	


Теорема 3 утверждает, что для LL(k)-грамматики управляющая таблица может быть построена без возникновения конфликтов. Если же её условие приводит к противоречиям, то грамматика не является LL(k).


Критерий того, что грамматика является LL(k) грамматикой, непосредственно следует из определения:
\begin{flushleft}
	
	\begin{tabular}  {p{2.20cm}  p{8.30cm}}
		{\bf\normalsize Лемма 4 (об эквивалентном определении)}
		& \emph{$G = \langle N, \Sigma, P, S \rangle$ является $LL(k)$ грамматикой тогда и только тогда, когда
			$(\forall A \vdash \alpha|\beta \in P) \Rightarrow ({FIRST_k(\alpha\gamma)\cap{FIRST_k(\beta\gamma)}}=$ $=\varnothing)$ при всех таких $\omega A \gamma$, что $S \vdash_{lm}^* \omega A \gamma$}.
	\end{tabular}
	
\end{flushleft}

Дальнейшие рассуждения и построения будут проводиться для $k=1$. Важно заметить, что при больших $k$ управляющая таблица сильно разрастается\footnote{Хоть и не показательно, как в теоретически худшем случае}, поэтому на практике алгоритм применим для небольших $k$.

В частном случае для $k = 1$:

{\bf$\blacktriangle$ Определение 8.}
$ FIRST(\alpha) = \{ a \in \Sigma \mid \exists \gamma \in (N \cup \Sigma)^*: $ $\alpha \vdash^* a \gamma \} $, где $ \alpha \in (N \cup \Sigma)^* $

{\bf$\blacktriangle$ Определение 9.}
$ FOLLOW(\beta) = \{ a \in \Sigma \mid \exists \gamma, \alpha \in (N \cup \Sigma)^* :$ $S \vdash^* \gamma \beta a \alpha \} \text{, где } \beta \in (N \cup \Sigma)^*  $
Множество $FIRST$ можно вычислить, пользуясь следующими соотношениями:

\begin{itemize}
	\item $FIRST(a \alpha) = \{a\}, a \in \Sigma, \alpha \in (N \cup \Sigma)^* $
	\item $FIRST(\varepsilon) = \{\varepsilon\}$
	\item $FIRST(\alpha \beta) = FIRST(\alpha) \cup (FIRST(\beta)$, если $ \varepsilon \in FIRST(\alpha))$
	\item $FIRST(A) = FIRST(\alpha) \cup FIRST(\beta) $, если в грамматике есть правило $ A \vdash \alpha \mid\beta$
\end{itemize}


\begin{algorithm}[H]
	
	\begin{algorithmic}
		\caption{Алгоритм для вычисления множества $FOLLOW$}\label{algo_follow}
		\Require Грамматика $G = \langle\Sigma, N, S, P\rangle$
		\Ensure $FOLLOW(A)$ для всех $A \in N$
		\State Положим $FOLLOW(X) \gets \varnothing, \forall X \in N$
		\State $FOLLOW(S) \gets FOLLOW(S) \cup \{\$\}$ , где $S$ --- стартовый нетерминал
		\While{множества $FOLLOW$ меняются}
		\State Для всех правил вида $A \vdash \alpha X \beta:$ 
		\State $FOLLOW(X) \gets FOLLOW(X) \cup (FIRST(\beta) \setminus \{\varepsilon\} )$.
		\State Для всех правил вида $A \vdash \alpha X \text{ и } A \vdash \alpha X \beta \text{, где } \varepsilon \in FIRST(\beta):$ 
		\State $FOLLOW(X) \gets FOLLOW(X) \cup FOLLOW(A)$
		\EndWhile
	\end{algorithmic}
\end{algorithm}
Алгоритм для вычисления множества $FOLLOW$ представлен в \ref{algo_follow}.

\textbf{$\blacktriangle$ Задача 1} Рассмотрим грамматику $G$ со следующими правилами:
\begin{itemize}
	\item $S  \vdash a S'$
	\item $A' \vdash b \mid a$
	\item $S' \vdash A b B S'\mid \varepsilon $
	\item $B  \vdash c \mid \varepsilon$
	\item $A  \vdash a A' \mid \varepsilon$
\end{itemize}

Посчитать множества FIRST и FOLLOW.\\

\hbox{%
	\color[gray]{0.85}{ \vrule width 4.0mm } \hspace{.5em} \color[rgb]{0,0,0} \parbox{0.9\textwidth}%
	{{\bf Решение}
		
		$FIRST$ для нетерминалов грамматики $G$:
		\begin{align*}
			FIRST(S)  &= \{ a \}  & FIRST(B)  &= \{ c, \varepsilon \} \\
			FIRST(A)  &= \{ a, \varepsilon \} & FIRST(S') &= \{ a, b, \varepsilon \}\\
			FIRST(A') &= \{ a, b \}   
		\end{align*}
		\medskip
		
		\noindent
	}
}
\hbox{%
	\color[gray]{0.85}{ \vrule width 4.0mm } \hspace{.5em} \color[rgb]{0,0,0} \parbox{0.9\textwidth}%
	{
		
		$FOLLOW$ для нетерминалов грамматики $G$:
		
		\begin{align*}
			FOLLOW(S)  &= \{ \$ \} & \\
			FOLLOW(S') &= \{ \$ \} &(S \vdash a S')\\
			FOLLOW(A)  &= \{ b \}  &(S' \vdash A b B S') \\
			FOLLOW(A') &= \{ b \}  &(A \vdash a A')\\
			FOLLOW(B)  &= \{ a, b, \$ \} &(S' \vdash A b B S', \varepsilon \in FIRST(S'))
		\end{align*}
		\medskip
		
		\noindent
		{\bf Задача решена.}}
}
\vspace{10pt}

Теперь рассмотрим пример грамматики, не являющейся LL(1).

\vspace{10pt}        
\textbf{$\blacktriangle$ Задача 2} Построить не-$LL(1)$ грамматику. 
\vspace{5pt}
\hbox{%
	\color[gray]{0.85}{ \vrule width 4.0mm } \hspace{.5em} \color[rgb]{0,0,0} \parbox{0.9\textwidth}%
	{{\bf Решение}
		
		Грамматика $S \vdash aS | a$, согласно теореме 4, не является LL(1)-грамматикой, так как $FIRST(aS)=FIRST(a)=\{a\}$ и $FIRST(aS)\cap{FIRST(a)}=\{a\}$, но LL(2)-грамматикой, так как $FIRST_2(aS)=\{aa\}$, $ FIRST_2(a)=\{a\}$, и $FIRST_2(aS)\cap{FIRST_2(a)}=\varnothing$ --- является.
		\medskip
		
		\noindent
		{\bf Задача решена.}}
}
Очевидно, что в случае LL(1)-грамматики управляющая таблица заполняется следующим образом: правила $A \vdash \alpha, \alpha \neq \varepsilon$ помещаются в ячейки с индексами $(A, a)$, где $a \in FIRST(\alpha)$, правила $A \vdash \alpha$~--- в ячейки $(A, a)$, где $a \in FOLLOW(A)$, если $\varepsilon \in FIRST(\alpha)$, а если при этом и $\$ \in FOLLOW(A)$, то и в ячейку $(A,\$)$.
Иногда, для небольших грамматик, в целях наглядности в таблицу добавляют 2 столбца с $FIRST,FOLLOW$ множествами для нетерминалов.

\textbf{$\blacktriangle$ Задача 3} Построить таблицу для грамматики $S \vdash aSbS \mid \varepsilon$ 
\vspace{5pt}
\hbox{%
	\color[gray]{0.85}{ \vrule width 4.0mm } \hspace{.5em} \color[rgb]{0,0,0} \parbox{0.9\textwidth}%
	{{\bf Решение}
		
		\begin{center}
			\begin{tabular}{ r || c | c || c | c | c }
				N & $FIRST$ & $FOLLOW$ & a & b & $\$ $ \\ \hline  
				$S$ & $\{ a, \varepsilon \}$ & $\{ b, \$ \}$ & $S \vdash aSbS$ & $S \vdash \varepsilon$ & $S \vdash \varepsilon$ 
			\end{tabular}  
		\end{center}
		\medskip
		
		\noindent
		{\bf Задача решена.}}
}

Теорема о связи LL(1)-грамматики с видом множеств $FIRST$ и $FOLLOW$ приведена ниже:
\begin{flushleft}
	
	\begin{tabular}  {p{2.20cm}  p{8.30cm}}
		{\bf\normalsize Лемма 5 (об эквивалентном определении)}
		& \emph{Грамматика $G = \langle \Sigma, N, S, P \rangle$ и $\omega \in \Sigma^{*}$ является LL(1) тогда и только тогда, когда выполнены 2 условия:
			\begin{enumerate}
				\item $(\forall A \vdash \alpha|\beta \in P) \Rightarrow$  $\Rightarrow({FIRST(\alpha)\cap{FIRST(\beta)}}=\varnothing)$ 
				\item $(\forall A \vdash \alpha|\beta \in P: \varepsilon \in FIRST(\alpha)) \Rightarrow$ $\Rightarrow({FOLLOW(A)\cap{FIRST(\beta)}}=\varnothing)$
			\end{enumerate}
			Здесь $\alpha,\beta \in (N\cup{\Sigma})^*$ --- две сентенциальные формы $G$.}
	\end{tabular}
	
\end{flushleft}

Вернёмся к решению задачи 2 в свете леммы 5.\\

\textbf{$\blacktriangle$ Задача 3} Проверить, что грамматика, задающая язык строк с равным количеством символов $a$ и $b$: $S \vdash aSbS|bSaS|\varepsilon$, не является LL(1).

\vspace{10pt}
\hbox{%
	\color[gray]{0.85}{ \vrule width 4.0mm } \hspace{.5em} \color[rgb]{0,0,0} \parbox{0.9\textwidth}%
	{{\bf Решение}
		
		Но грамматика содержит правило $S \vdash \varepsilon$, и $\varepsilon \in FIRST(\varepsilon)$, следовательно, нужно проверять (2).
		$FOLLOW(S)=\{a,b,\$\}$ имеет непустое пересечение как с $FIRST(aSbS)$, так и с $FIRST(bSaS)$, поэтому (2) не выполняется, и грамматика не является LL(1).
		
		Но грамматика содержит правило $S \vdash \varepsilon$, и $\varepsilon \in FIRST(\varepsilon)$, следовательно, нужно проверять (2).
		$FOLLOW(S)=\{a,b,\$\}$ имеет непустое пересечение как с $FIRST(aSbS)$, так и с $FIRST(bSaS)$, поэтому (2) не выполняется, и грамматика не является LL(1).
		\medskip
		
		\noindent
		{\bf Задача решена.}}
}

Условия критерия накладывают довольно серьёзные ограничения на вид грамматики. В особенности:
\begin{enumerate}
	\item Грамматика должна быть однозначной:
	
	\begin{example}
		\begin{align*}
			G: & \\
			S \vdash aA | B | c & \\
			A \vdash b|aA & \\
			B \vdash aA|a\varepsilon &
		\end{align*}
		Если анализируемая строка начинается с $a$, невозможно сделать однозначный выбор между $S \vdash aA$ и $ S\vdash B$. 
	\end{example}
	\item Даже вывод $\varepsilon$ из двух правил альтернативы невозможен:
	
	\begin{example}
		\begin{align*}
			G: & \\
			S \vdash aA & \\
			A \vdash BC|B & \\
			C \vdash b|\varepsilon & \\
			B \vdash \varepsilon &
		\end{align*}
		Рассмотрим два разных левых порождения $a$ в $G$:
		\begin{itemize}
			\item $S \vdash_{lm} \underline{aA} \vdash_{lm} \underline{aB} \vdash_{lm} a$
			\item $S \vdash_{lm} \underline{aA} \vdash_{lm} \underline{aBC} \vdash_{lm} a$
		\end{itemize}
		В виду того, что из $B\vdash_{lm}^*\varepsilon$ и $BC\vdash_{lm}^*\varepsilon$, нельзя однозначно произвести подчёркнутый шаг левого порождения, $a$ в $G$ имеет два различных дерева вывода, и грамматика не является LL(1).
	\end{example}
\end{enumerate}

\subsection{LL-алгоритм синтаксического анализа}

LL(k) --- синтаксический анализ --- семейство алгоритмов нисходящего анализа без отката, с предпросмотром. Решение о том, какое правило применять, принимается по управляющей таблице $T_k$ на основании просмотра $k$ символов, непосредственно следующих за текущим во входной строке. 
Временная сложность алгоритма $O(n)$, где $n$~--- длина входной строки. 

Для КС грамматики $\langle \Sigma, N, P, T\rangle$ алгоритм использует:
\begin{itemize}
	\item входной буфер с указателем на позицию текущего символа
	\item стек с алфавитом $\Gamma=N\cup\Sigma\cup{\{\$\}}$ для хранения промежуточных данных
	\item таблицу $T_k$, управляющую разбором.
\end{itemize}

При чтении анализируемой строки во входе, алгоритм может заглядывать вперёд на $k$ символов. 

Конфигурацией алгоритма назовём пару $\langle x, X\alpha \rangle$ из множества таких пар $Q$, где $x$ --- неразобранная часть входной строки, $X\alpha \in \Gamma^*$ --- содержимое стека, $X \in \Gamma$ --- символ на вершине. 
При анализе строки $w$ будем называть конфигурацию $\langle w, S\$ \rangle$ --- стартовой, конфигурацию $\langle \$, \$ \rangle$ --- конечной. Алгоритм, начиная со стартовой, на каждом шаге анализирует текущую конфигурацию, и выполняет действия, с учётом прочитанной части анализируемой строки: определяется цепочка исследуемых входных символов $u, |u| \leq {k}$ и символ на вершине стека $X$, затем, если $X \in N$, рассматривается элемент управляющей таблицы $T_k(X,u)$, и замена содержимого вершины стека правой частью правила из этого элемента; если $X$ -- терминальный символ, происходит сравнение c первым символом $u$, и в случае совпадения -- извлечение $X$ и сканирование очередного символа из ввода.

Опишем действия над конфигурациями, $\{f: Q \to Q, f \in \{match, lookup, success, error\}\}$, выполняемые в ходе работы алгоритма:
\begin{itemize}
	\item \textbf{match} --- в случае, когда на вершине стека --- терминал, и символ на текущей позиции равен этому терминалу, то снять элемент со стека, сдвинуть указатель на 1 позицию вправо.
	$\langle x, X\alpha \rangle$ переводится в $\langle x', \alpha \rangle$, если $x=ax'$ и $X = a$
	\item \textbf{lookup} --- в случае, когда текущая врешина стека --- нетерминал $X_i$, и предпросмотрена подстрока $u$, найти в управляющей таблице $T$ ячейку с координатами $(X_i, u)$, положить на стек содержимое правой части этой ячейки так, чтобы самый левый символ оказался на вершине. $\langle x, X\alpha \rangle$ переводится в $\langle x, \beta\alpha \rangle$, если $T_k(X,u)=X\vdash{\beta}$ и $X = a$
	\item \textbf{success} --- pавершить работу при достижении конфигурации $\langle\$,\$\rangle$
	\item \textbf{error} --- сигнализировать об ошибке и завершить работу.
\end{itemize}
Если алгоритм оказался в конечной конфигурации --- разбор успешно завершён.

\subsubsection{Алгоритм LL(1)-анализа}

Опишем работу алгоритма LL(1)-анализа, как частного случая LL-анализа с предпросмотром на $k=1$ символ. Алгоритм по-прежнему использует входную строку, управляющую таблицу, стек, и работает следующим образом:

\begin{algorithm}
	\begin{algorithmic}
		\State {$stack.push(\$,S)$}
		\State {$c \gets input.scan()$}
		
		\While{$stack.top() \neq \$$}
		\State $X \gets stack.top()$
		\If{$X=c$} // \textit{match:}
		\State{$stack.pop()$}
		\State{$c \gets input.scan()$}
		\ElsIf{$X \in N$} // \textit{lookup(X,c):}
		\If{$T[X,c]=X\vdash X_1\dots X_m$}
		\State {$stack.pop()$} 
		\State {$stack.push(X_m,\dots,X_1)$}
		\Else
		\State ошибка: пустая ячейка таблицы! //\textit{error}
		\EndIf
		\Else
		\State ошибка! //\textit{error}
		\EndIf
		\EndWhile
		
		\If{$c \neq \$$}
		\State ошибка: не вся строка разобрана! //\textit{error}
		\EndIf	//\textit{success}	
	\end{algorithmic}
	
\end{algorithm}
\begin{itemize}
	
	\item На каждом шаге алгоритма его конфигурация --- это позиция во входной строке, начиная с которой расположена неразобранная её часть, и стек.
	\item В начале работы стек пуст, а позиция во входной строке соответствует её началу.
	На певом шаге в стек добавляются последовательно $\$$ и cтартовый нетерминал $S$.
	\item На каждом шаге анализируется текущая конфигурация и совершается одно из действий:
	\begin{itemize}
		\item Действие $\textbf{success}$. Если текущая позиция --- конец строки, и вершина стека --- символ конца строки, то разбор успешно завершен. Иначе, если стоим на конце строки --- \textbf{error}.
		\item Действие $\textbf{match}$. Если текушая вершина стека --- терминал, то анализатор проверяет, что позиция в строке соответствует этому терминалу. Если да, то снимает элемент со стека, сдвигает указатель на 1 позицию вправо, и продолжает разбор.
		Иначе --- завершает разбор с ошибкой --- \textbf{error}.
		\item Действие $\textbf{lookup}$. Если текущая врешина стека --- нетерминал $X_i$, и текущий входной символ $c$, то ищет в управляющей таблице $T$ ячейку с координатами $(X_i, c)$ и кладёт на стек содержимое правой части этой ячейки так, чтобы самый левый символ оказался на вершине (операция $stack.push$ применена к символам правой части справа налево), иначе сигнализирует об ошибке --- \textbf{error}.
	\end{itemize}
\end{itemize}

\begin{example}Пример работы LL(1) анализатора.
	Рассмотрим грамматику $S \vdash aSbS \mid \varepsilon$ и выводимое слово $\omega = abab$.
	
	Расмотрим пошагово работу LL(1)-алгоритма. Используем управляющую таблицу, построенную в предыдущем примере. Символ строки, доступный по указателю позиции в строке, выделен жирным шрифтом.
	
	
	\begin{enumerate}
		\item Начало работы.
		
		Стек: \begin{tabular}[c]{ |c|c|c|c|c| }
			\hline
			\\ \hline
		\end{tabular} \\ 
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			\textbf{a} & b & a & b & \$ \\ \hline
		\end{tabular}
		
		Стек пуст, по указателю доступен первый символ слова.
		
		\item Кладём $\$$ и стартовый символ $S$ на стек
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| }
			\hline
			$S$ & \$ \\ \hline
		\end{tabular} \\ 
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			\textbf{a} & b & a & b & \$ \\ \hline
		\end{tabular}
		
		\item Ищем ячейку с координатами (S, a), применяем правило из ячейки.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$a$ 
			& $S$ 
			& $b$ 
			& $S$ 
			& \$ \\ \hline
		\end{tabular}\\  
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			\textbf{a} & b & a & b & \$ \\ \hline
		\end{tabular}
		
		\item Снимаем терминал $a$ со стека и сдвигаем указатель.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$S$ 
			& $b$  
			& $S$ 
			& \$ \\ \hline
		\end{tabular} \\
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & \textbf{b} & a & b & \$ \\ \hline
		\end{tabular}
		
		\item Ищем ячейку с координатами (S, b), применяем правило из ячейки.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$b$ 
			& $S$
			& \$ \\ \hline
		\end{tabular}\\  
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & \textbf{b} & a & b & \$ \\ \hline
		\end{tabular}
		
		\item Снимаем терминал $b$ со стека и сдвигаем указатель.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$S$
			& \$ \\ \hline
		\end{tabular}\\  
		Входное слово: \,
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & b & \textbf{a} & b & \$ \\ \hline
		\end{tabular}
		
		\item Ищем ячейку с координатами (S, a), применяем правило из ячейки.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$a$ 
			& $S$ 
			& $b$ 
			& $S$
			& \$ \\ \hline
		\end{tabular} \\  
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & b & \textbf{a} & b & \$ \\ \hline
		\end{tabular}
		
		\item Снимаем терминал $a$ со стека и сдвигаем указатель.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$S$
			& $b$
			& $S$
			& \$ \\ \hline
		\end{tabular} \\
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & b & a & \textbf{b} & \$ \\ \hline
		\end{tabular}
		
		\item Ищем ячейку с координатами (S, b), применяем правило из ячейки.
		
		Стек: \,
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$b$
			& $S$
			& \$ \\ \hline
		\end{tabular} \\  
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & b & a & \textbf{b} & \$ \\ \hline
		\end{tabular}
		
		\item Снимаем терминал $b$ со стека и сдвигаем указатель.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			$S$
			& \$ \\ \hline
		\end{tabular} \\  
		Входное слово: \,
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & b & a & b & \textbf{\$} \\ \hline
		\end{tabular}
		
		\item Ищем ячейку с координатами (S, \$), применяем правило из ячейки.
		
		Стек:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			
			\$ \\ \hline
		\end{tabular} \\  
		Входное слово:
		\begin{tabular}[c]{ |c|c|c|c|c| } 
			\hline
			a & b & a & b & \textbf{\$} \\ \hline
		\end{tabular}    
		
		\item Оказались в конце строки и на вершине стека символ конца --- завершаем разбор.
		
	\end{enumerate}
	
\end{example}


\begin{table}[H]
	\begin{center}
		\begin{tabular}{ |c|l|c|l| }
			\hline
			\textbf{Шаг} & \textbf{Стек} & \textbf{Остаток строки} & \textbf{Текущее действие}\\ 
			\hline
			\textbf{0} & | & \textbf{abab\$} & \textbf{$stack.push(\$,S)$} \\
			\hline
			\textbf{1} & |\$|S & \textbf{abab\$} & \textbf{$lookup(S,a)$} \\
			\hline
			\textbf{2} & |\$|S|b|S|a & \textbf{abab\$} & \textbf{$match$} \\
			\hline
			\textbf{3} & |\$|S|b|S & \textbf{bab\$} & \textbf{$lookup(S,b)$} \\
			\hline
			\textbf{4} & |\$|S|b & \textbf{bab\$} & \textbf{$match$} \\
			\hline
			\textbf{5} & |\$|S & \textbf{ab\$} & \textbf{$lookup(S,a)$} \\
			\hline
			\textbf{6} & |\$|S|b|S|a & \textbf{ab\$} & \textbf{$match$} \\
			\hline
			\textbf{7} & |\$|S|b|S & \textbf{b\$} & \textbf{$lookup(S,b)$} \\
			\hline
			\textbf{8} & |\$|S|b & \textbf{b\$} & \textbf{$match$} \\
			\hline
			\textbf{9} & |\$|S & \textbf{\$} & \textbf{$lookup(S,\$)$} \\
			\hline
			\textbf{10} & |\$ & \textbf{\$} & \textbf{$match$} \\
			\hline
			
		\end{tabular}
		\caption{Разбор слова $abab$ в грамматике $S \vdash aSbS \mid \varepsilon$ по LL(1)-алгоритму}
		\label{parsing_exmpl1}
	\end{center}
\end{table}


Можно расширить данный алгоритм так, чтобы он строил дерево вывода. Дерево будет строиться сверху вниз, от корня к листьям. Для этого необходимо расширить действия:
\begin{itemize}
	\item В ситуации, когда выполняется \textbf{match} (на вершине стека и во входе --- одинаковые терминалы), нужно создать листовую вершину с соответствующим терминалом.
	\item В ситуации, когда нетерминал в стеке заменяется на правую часть правила в ходе выполнения \textbf{lookup}, нужно создать нелистовую вершину, соответствующую нетерминалу в левой части применяемого правила.
\end{itemize} 

Дерево вывода для LL(1), как и в целом для LL(k), будет строиться однозначно, что следует из однозначности грамматик.

Также отметим, что LL-анализ, как и безоткатный рекурсивный спуск, не работает с леворекурсивными грамматиками: алгоритм может зациклиться. Таким образом, по некоторым грамматикам можно построить LL(k)-анализатор (для LL(k) грамматик), но не по всем. Методы борьбы с левой рекурсией даны в следующих разделах, а вот с неоднозначностями ничего не поделаешь.
\subsection{Рекурсивный спуск}

Идея рекурсивного спуска основана на использовании стека вызовов программы в качестве стека анализатора следующим образом:

\begin{itemize}
	\item Для каждого нетерминала программируется функция, принимающая необработанный остаток строки $s$ и возвращающая пару: результат вывода префикса данной строки из соответствующего нетерминала (выводится/не выводится) и новый необработанный остаток строки.
	\item Каждая функция реализует обработку цепочки согласно правым частям правил для соответствующих нетерминалов: считывание символа ввода при обработке терминального символа, вызов соответствующей функции при обработке нетерминального.
\end{itemize}

У данного подхода есть два ограничения:
\begin{enumerate}
	\item Неприменим для грамматик, содержащих левую рекурсию. Иначе анализатор может зациклиться.
	\item Шаги должны быть однозначными. Иначе нет возможности детерминированно выбрать конкретную функцию для вызова в некоторых ситуациях.
\end{enumerate}

Если в грамматике, для которой разрабатывается рекурсивный спуск, есть альтернатива $A \vdash u_1|\dots|u_z$, то однозначный выбор применяемой функции обработки нетерминала $A$ (либо применяемого правила в вызываемой функции, если для каждого правила в альтернативе не реализована отдельная функция) может быть автоматизированно осуществлён по проверке условия наличия префикса ещё не обработанной части строки $s$ длины не более $k$ в $FIRST_k(u_j), j \in [1,z]$, причём условие должно выполняться не более чем для одного $j$, иначе грамматика неоднозначна. Если такой $j$ не найден, но существует  $\hat{j} \in [1,z]$, такой, что, $u_{\hat{j}} \vdash^{*} \varepsilon$ , и данный префикс принадлежит $FOLLOW_k(A)$, то можно положить $j=\hat{j}$. В данных и только в данных случаях правило $A \vdash u_j$ может быть выбрано для применения. Следовательно, для однозначного выбора правила требуется проанализировать $FIRST_k(A)$ и $FOLLOW_k(A)$, и, классически, рекурсивному спуску подлежат языки, задаваемые классом LL(k) грамматик\footnote{на практике это ограничение может быть ослаблено различными ухищрениями, вроде откатов и пр.}.

Приведём алгоритм выбора правила из альтернативы для $k=1$.

\begin{algorithm}[H]\label{alg:RD_PICK_ALT}
	\begin{algorithmic}
		\State Рассматривается альтернатива: $A \vdash {u_1|\dots|u_z}$
		\State $inSym$ -- первый символ необработанной части строки
		\If{($\exists j \in [1,z]):inSym \in FIRST(u_{j}))$}
		\State Выбрать правило $A \vdash u_{j}$
		\ElsIf{($\exists \hat{j} \in [1,z]): u_{\hat{j}} \vdash^{*} {\varepsilon} \And{inSym \in FOLLOW(A)})$}
		\State Выбрать правило $A \vdash u_{\hat{j}}$
		\Else
		\State {Ошибка!}
		\EndIf
	\end{algorithmic}
\end{algorithm}


Приведём общий вид функции обработки $funcA$ нетерминала $A$, символически обозначая считывание символа из входного потока $s$, моделируемого объектом класса строки, реализующего методы $s.current$, возвращающий символ в текущей позиции, и $s.scan$, который возвращает терминальный символ и модифицирует $s$ так, что в нём после вызова $c=s.scan()$ остаток строки, расположенный за $c$. Если возвращаеммое значение самой первой в стеке вызовов функции  --- пара вида \textit{(True, [])}, то разбор завершился успехом. Временная сложность алгоритма от длины строки $n$ --- $O(n)$, так как строка сканируется только один раз.

\begin{algorithm}[H]\label{alg:RD}
	%\caption{$funcA(s: str,A)\vdash{(status: bool, substr: str)}$}\label{alg:rd1}
	\begin{algorithmic}
		\If{$len(s)=0$}
		\State $return (True,w)$
		\EndIf
		\State Текущее правило: $A \vdash {X_1X_2\dots{X_k}}$
		\For{$i \in [1,k]$}
		\If{$X_i \in N$}
		\State $res, s \gets funcX_i(s)$ // $call$, $C()$
		\If{$res = False$}
		\State {$return\ (False, s)$} // $return$, $R()$
		\EndIf
		
		\ElsIf{$(X_i \in \Sigma\cup{\{\varepsilon\}}) \And  (( X_i = \varepsilon) || X_i=s.current()) $}
		\State {\textbf{if} $X_i \neq \varepsilon$: $s.scan()$} // $match\_terminal$, $M_{\Sigma}()$
		\If{$i=k$}
		\State {$return\ (True, s)$} // $return$, $R()$
		\EndIf
		\Else
		\State {$return\ (False, s)$} // $return$, $R()$
		\EndIf
		\EndFor
	\end{algorithmic}
\end{algorithm}
Заметим, что алгоритм совершает 3 типа действий\footnote{Как правило, на практике эти действия не формализуют}:
\begin{enumerate}
	\item \textbf{call}, $C()$: если символ на текущей позиции рассматриваемого правила --- нетерминал, совершить вызов функции его обработки. 
	\item \textbf{return}, $R()$: возврат из вызова. Производится при попытке сдвига с крайней правой позиции в рассматриваемом правиле, либо в случае пустого слова во вводе, либо в случае ошибки.
	\item \textbf{match terminal}, $M_{\Sigma}()$: eсли символ на текущей позиции в правиле --- $\varepsilon$, просто сдвинуть позицию на 1. Если терминал --- проверить соответствие его текущему входному символу, и, если они равны, то сдвинуть позицию в правиле на 1 и считать следующий символ.
\end{enumerate}

Заметим, что действия \textbf{call} и \textbf{return} реализуют логику \textbf{lookup} из алгоритма анализа по таблице, \textbf{match terminal} --- логику \textbf{match}.


Рассмотрим работу рекурсивного спуска реализующего разбор слова $aabb$ по грамматике $S \vdash aSbS \mid \varepsilon$
\begin{table}[H]
	\begin{center}
		\begin{tabular}{ |c|l|c|l| }
			\hline
			\textbf{Шаг} & \textbf{Стек вызовов} & \textbf{Остаток строки} & \textbf{Текущее действие}\\ 
			\hline
			\textbf{0} & |main|\textbf{S(aabb\$)} & \textbf{aabb\$} & \textbf{$M_{\Sigma}(S\vdash{\textbf{a}SbS},aabb\$)$} \\
			\hline
			\textbf{1} & |main|\textbf{S(aabb\$)} & \textbf{abb\$} & \textbf{$C(S\vdash{a\textbf{S}bS},S)$} \\
			\hline
			\textbf{2} & |main|S|\textbf{S(abb\$)} & \textbf{abb\$} & \textbf{$M_{\Sigma}(S\vdash{\textbf{a}SbS},abb\$)$} \\
			\hline
			\textbf{3} & |main|S|\textbf{S(abb\$)} & \textbf{bb\$} & \textbf{$C(S\vdash{a\textbf{S}bS},S)$} \\
			\hline
			\textbf{4} & |main|S|S|\textbf{S(bb\$)} & \textbf{bb\$} & \textbf{$M_{\Sigma}(S\vdash{\varepsilon},bb\$), R()$} \\
			\hline
			\textbf{5} & |main|S|\textbf{S(abb\$)} & \textbf{bb\$} & \textbf{$M_{\Sigma}(S\vdash{aS\textbf{b}S},bb\$)$} \\
			\hline
			\textbf{6} & |main|S|\textbf{S(abb\$)} & \textbf{b\$} & \textbf{$C(S\vdash{aSb\textbf{S}},S)$} \\
			\hline
			\textbf{7} & |main|S|S|\textbf{S(b\$)} & \textbf{b\$} & \textbf{$M_{\Sigma}(S\vdash{\varepsilon},b\$), R()$} \\
			\hline
			\textbf{8} & |main|S|\textbf{S(abb\$)} & \textbf{b\$} & \textbf{$R()$} \\
			\hline
			\textbf{9} & |main|\textbf{S(aabb\$)} & \textbf{b\$} & \textbf{$M_{\Sigma}(S\vdash{aS\textbf{b}S},b\$)$} \\
			\hline
			\textbf{10} & |main|\textbf{S(aabb\$)} & \textbf{\$} & \textbf{$C(S\vdash{aSb\textbf{S}},S)$} \\
			\hline
			\textbf{11} & |main|S|\textbf{S(\$)} & \textbf{\$} & \textbf{$M_{\Sigma}(S\vdash{\varepsilon},\$), R()$} \\
			\hline
			\textbf{12} & |main|\textbf{S(aabb\$)} & \textbf{\$} & \textbf{$R()$} \\
			\hline
		\end{tabular}
		\caption{Разбор слова $aabb$ в грамматике $S \vdash aSbS \mid \varepsilon$ рекурсивным спуском.}
		\label{parsing_exmpl2}
	\end{center}
\end{table}





%	Приведённый в листинге вариант реализации рекурсивного спуска является безоткатным: в случае ошибки происходит возврат статуса $False$ и остатка необработанной строки. Тем не менее, в общем случае (и зачастую на практике так и есть), рекурсивный спуск может потребовать отката по строке, с возвращением уже прочитанных символов во ввод\footnote{как правило, на практике эти действия выполняются модулем лексического анализа под управлением синтаксического анализатора} и повторным сканированием с целью попытки применить другое правило.

%	Пример ниже демонстрирует умышленное использование отката при анализе программы на языке $C$.
%	\begin{example}
	%	Рассмотрим 2 конструкции языка $C$:
	%	\begin{enumerate}
		%		\item \verb|static tp = 5;|
		%		\item \verb|static tp v = 5;|
		%	\end{enumerate}
	%	В силу того, что в языке $C$ примитивный тип $int$ может быть указан неявно при объявлении переменной, а так же есть возможность задания пользовательского типа $tp$, анализатор, просмотрев часть входной строки из двух токенов --- \verb|static tp|, не может однозначно определить, какое правило применить: \verb|tp| может быть типом, а может быть именем переменной. В таком случае анализатор пытается считать следующий токен за \verb|tp|, и, если это оказался декларатор, применяет правило для объявления переменной $v$ типа $tp$, в противном случае производится возврат прочитанного токена обратно во входной поток посредством вызова соотвествующей команды лексического анализатора, и применяется другое правило.
	
	%	Следует отметить, что некоторые из подобных правил с альтернативой могут быть преобразованы левой факторизацией, но не все. Поэтому использование отката в рекурсивном спуске --- скорее практическая необходимость, продиктованная неподходящей исходной грамматикой.
	
	%	\end{example}
%	Основной теоретический недостаток рекурсивного спуска с откатом --- теоретически экспоненциальная сложность от длины строки, как правило, не реализуемая на практике.
%	Несмотря на то, что в литературе[Ахо, Ульман, Серебряков, др.] обычно указывается предпочтительность использования табличных методов, на практике в модулях синтаксического анализа большинства современных промышленных компиляторов С, C++, Fortran, Rust используется вручную реализованный рекурсивный спуск с поддержкой отката\footnote{используется в Clang, современном GCC, Rust C, MSVC на момент осени 2023 г.}. Для изначально просто спроектированных языков типа $Pascal$, рекурсивный спуск можно реализовать без отката, так подобрана грамматика.

Данный подход применяется как для ручного написания синтаксических анализаторов, так и при генерации анализаторов по грамматике, например средствами ANTLR. 

\subsection{Преобразования грамматики к LL(1)}

Иногда грамматику $G = \langle \Sigma, N, S, P \rangle$, не являющуюся LL(1), можно привести к LL(1) грамматике. В первую очередь, можно применить методы устранения левой рекурсии и левую факторизацию. Следует отметить, что в ходе преобразований не всякая грамматика становится LL(1), а также то, что грамматика может стать менее понятной. Также доказано, что существование LL грамматики, эквивалентной $G$, является алгоритмически неразрешимой задачей. 

\subsubsection{Устранение левой рекурсии}
Непосредственная левая рекурсия, то есть правила вида $A \vdash A\alpha$, можно устранить следующим образом.

\begin{enumerate}
	\item Группируем правила с $A$ в левой части:
	$A \vdash A\alpha_1|\dots|A\alpha_m|\beta_1|\dots|\beta_n$, где никакая из сентенциальных форм $\beta_i$ не начинается с $A$.
	\item Добавляем новый нетерминал $A'$
	\item Заменяем этот набор правил на
	
	\begin{align*} 
		A \vdash \beta_1 A'|\dots|\beta_n A' \\
		A' \vdash \alpha_1 A'|\dots|\alpha_m A'|\varepsilon
	\end{align*}
\end{enumerate} 

Теперь из $A$ можно вывести те же строчки, что и раньше, но без левой рекурсии. Заметим, что в ходе данного преобразования появляются новые $\varepsilon$-правила, по одному на каждый добавленный нетерминал.
Метод выше устраняет только непосредственную левую рекурсию.

Пусть дана грамматика $G = \langle \Sigma, N, S, P \rangle$, не содержащая $\varepsilon$-правил. Для удаления из $G$ скрытой левой рекурсии, включающей два и более шага, применяется следующий алгоритм:

\begin{algorithm}
	\begin{algorithmic}
		\State {Нетерминалы пронумерованы в произвольном порядке, $n \gets |N|$}
		\For{$i \in [1,n]$}
		\For{$j \in [1,i-1]$}
		\State $A_j \vdash \beta_1|\dots|\beta_k$ --- все текущие правила для $A_j$
		\State Заменить все $A_i \vdash A_j\alpha$ на $A_i \vdash \beta_1\alpha|\dots|\beta_k\alpha$
		\EndFor
		\State удалить правила $A_i \vdash A_i$
		\State устранить непосредственную левую рекурсию для $A_i$.
		\EndFor
	\end{algorithmic}
	
\end{algorithm}
Полученная грамматика не содержит левой рекурсии. В ходе преобразования могут появиться $\varepsilon$-правила.

\subsubsection{Левая факторизация}
Идея левой факторизации лежит в том, чтобы в случае, когда неясно, какую из альтернатив применять для раскрытия нетерминала $A$, изменить правила для $A$ так, чтобы отложить решение до тех пор, пока не будет достаточно информации для принятия однозначного решения.

Преобразование: для правил $A\vdash \alpha\beta_1|\alpha\beta_2$ грамматики $G = \langle \Sigma, N, S, P \rangle$ и непустой строчки с префиксом, выводимым из $\alpha$, когда неизвестно, какое правило применять, можно добавить новое правило $A\vdash\alpha A'$, и после анализа того, что выводимо из $\alpha$, попробовать применить новое правило $A' \vdash \beta_1$ либо $A' \vdash \beta_2$.

\begin{algorithm}
	\begin{algorithmic}
		\While {В грамматике есть альтернативы с общим префиксом}
		\State{Для каждого $A \in N$ найти самый длинный префикс $\alpha$ для альтернатив в $P$ с $A$ в левой части.}
		\If{$\alpha \neq \varepsilon$}
		\State {Заменить все $A\vdash \alpha\beta_1|\dots|\alpha\beta_m|\gamma$ на:}
		\State{$A\vdash\alpha A'|\gamma$}
		\State{$A' \vdash \beta_1|\dots|\beta_m$}
		\EndIf
		\EndWhile
	\end{algorithmic}
	
	
\end{algorithm}

После преобразования грамматика может стать не LL(1) (см. задачу 3).
%Для рекурсивного спуска без отката также существует как критерий применимости, так и каноническая форма правил, конструктивно выражаемые в терминах вида множеств $FIRST$ и $FOLLOW$, и следующие непосредственно из особенности программной реализации.

%\begin{theorem}
%	Рекурсивный спуск без отката для грамматики $G = \langle \Sigma, N, S, P \rangle$ и $\omega \in \Sigma^{*}$ может быть реализован тогда и только тогда, когда для любого правила с альтернативой $A\vdash \alpha | \beta \in P$ выполнены условия:
%	\begin{enumerate}
	%		\item $FIRST(\alpha)\cap{FIRST(\beta)}=\varnothing$
	%		\item $\varepsilon$ не может быть выведен одновременно и из $\alpha$, и из $\beta$
	%			\item Если $\beta \vdash^*\varepsilon$, то $FIRST(A)\cap{FOLLOW(A)}=\varnothing$
	%		\end{enumerate}
%	\end{theorem}


\clearpage
